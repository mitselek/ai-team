#!/usr/bin/env python3
"""
MCP Server: Kali Linux Penetration Testing Tools

Educational security testing server with network scanning and vulnerability assessment tools.
Run in isolated Docker environment with proper security controls.

WARNING: For educational and authorized testing only. Unauthorized scanning is illegal.
"""

import asyncio
import ipaddress
import json
import logging
import os
import re
from pathlib import Path
from typing import Any

import docker
from dotenv import load_dotenv
from mcp.server import Server
from mcp.server.stdio import stdio_server
from mcp.types import Tool, TextContent

# Load environment variables from .env file
env_path = Path(__file__).parent.parent / '.env'
load_dotenv(env_path)

# Configure logging
logging.basicConfig(
    level=os.getenv("LOG_LEVEL", "INFO"),
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger("mcp-kali-pentest")

# Configuration
DOCKER_IMAGE = os.getenv("KALI_DOCKER_IMAGE", "kalilinux/kali-rolling")
CONTAINER_USER = os.getenv("CONTAINER_USER", "kali")
MAX_TIMEOUT = int(os.getenv("MAX_TIMEOUT", "300"))  # 5 minutes
ALLOWED_NETWORKS = os.getenv("ALLOWED_NETWORKS", "127.0.0.1,localhost").split(",")

# Initialize Docker client
try:
    docker_client = docker.from_env()
    logger.info("Docker client initialized successfully")
except Exception as e:
    logger.error(f"Failed to initialize Docker client: {e}")
    docker_client = None

# Create MCP server
app = Server("mcp-kali-pentest")


def sanitize_target(target: str) -> str:
    """
    Sanitize scan target to prevent command injection.
    
    Args:
        target: IP address, hostname, or CIDR range
        
    Returns:
        Sanitized target string
        
    Raises:
        ValueError: If target contains invalid characters
    """
    # Allow only alphanumeric, dots, hyphens, slashes (for CIDR), and colons (for IPv6)
    if not re.match(r'^[a-zA-Z0-9\.\-\/\:]+$', target):
        raise ValueError(f"Invalid target format: {target}")
    
    # Block common command injection attempts
    dangerous_chars = [';', '|', '&', '$', '`', '(', ')', '<', '>']
    if any(char in target for char in dangerous_chars):
        raise ValueError(f"Target contains dangerous characters: {target}")
    
    return target


def check_network_permission(target: str) -> bool:
    """
    Check if scanning the target network is permitted.
    
    Args:
        target: Target IP or hostname
        
    Returns:
        True if allowed, False otherwise
    """
    # For educational purposes, restrict to localhost/internal networks
    for allowed in ALLOWED_NETWORKS:
        # Direct string match for hostnames like 'localhost'
        if allowed in target:
            return True
        
        # Try parsing as CIDR network
        try:
            # Parse target as IP
            target_ip = ipaddress.ip_address(target.split('/')[0])
            # Parse allowed as network
            allowed_net = ipaddress.ip_network(allowed, strict=False)
            if target_ip in allowed_net:
                return True
        except (ValueError, AttributeError):
            # Not a valid IP/network, continue to next
            continue
    
    logger.warning(f"Scan target {target} not in allowed networks")
    return False


async def run_docker_command(
    command: list[str],
    timeout: int = MAX_TIMEOUT
) -> dict[str, Any]:
    """
    Execute security tool command in Kali Docker container.
    
    Args:
        command: Command and arguments to execute
        timeout: Maximum execution time in seconds
        
    Returns:
        Dict with stdout, stderr, and exit_code
        
    Raises:
        RuntimeError: If Docker execution fails
    """
    if docker_client is None:
        raise RuntimeError("Docker client not initialized")
    
    try:
        logger.info(f"Executing command: {' '.join(command)}")
        
        # Run container with security constraints
        # Note: Running as root is necessary for network scanning tools that require raw sockets
        # Security is maintained through: isolated container, dropped caps (except NET_*), 
        # read-only FS, resource limits, and input validation
        container = docker_client.containers.run(
            DOCKER_IMAGE,
            command=command,
            user="root",  # Required for nmap/network tools to access raw sockets
            detach=True,
            remove=False,  # Don't auto-remove, we'll remove manually after getting logs
            network_mode="bridge",
            cap_drop=["ALL"],  # Drop all capabilities
            cap_add=["NET_RAW", "NET_ADMIN"],  # Only network capabilities needed for scanning
            security_opt=["no-new-privileges"],
            read_only=True,
            mem_limit="512m",
            cpu_quota=50000  # 50% CPU
        )
        
        # Wait for completion with timeout
        result = container.wait(timeout=timeout)
        logs = container.logs().decode('utf-8', errors='replace')
        
        # Clean up container
        try:
            container.remove(force=True)
        except Exception as cleanup_error:
            logger.warning(f"Failed to remove container: {cleanup_error}")
        
        return {
            "stdout": logs,
            "stderr": "",
            "exit_code": result.get("StatusCode", -1)
        }
        
    except docker.errors.ContainerError as e:
        logger.error(f"Container error: {e}")
        return {
            "stdout": "",
            "stderr": str(e),
            "exit_code": e.exit_status
        }
    except docker.errors.ImageNotFound:
        raise RuntimeError(f"Docker image {DOCKER_IMAGE} not found. Run: docker pull {DOCKER_IMAGE}")
    except Exception as e:
        logger.error(f"Docker execution failed: {e}")
        raise RuntimeError(f"Failed to execute command: {str(e)}")


@app.list_tools()
async def list_tools() -> list[Tool]:
    """List available security testing tools."""
    return [
        Tool(
            name="nmap_scan",
            description="Network port scanner - discover hosts and services on a network. Use for port scanning, service detection, and OS fingerprinting.",
            inputSchema={
                "type": "object",
                "properties": {
                    "target": {
                        "type": "string",
                        "description": "Target IP address, hostname, or CIDR range (e.g., 192.168.1.1, scanme.nmap.org, 10.0.0.0/24)"
                    },
                    "scan_type": {
                        "type": "string",
                        "enum": ["quick", "full", "stealth", "udp", "service"],
                        "default": "quick",
                        "description": "Scan type: quick (-T4 -F), full (-p-), stealth (-sS), udp (-sU), service (-sV)"
                    },
                    "additional_args": {
                        "type": "string",
                        "description": "Additional nmap arguments (optional, use with caution)"
                    }
                },
                "required": ["target"]
            }
        ),
        Tool(
            name="nikto_scan",
            description="Web server vulnerability scanner - checks for dangerous files, outdated software, and security issues. Use for web application security assessment.",
            inputSchema={
                "type": "object",
                "properties": {
                    "target": {
                        "type": "string",
                        "description": "Target URL (e.g., http://example.com, https://192.168.1.100)"
                    },
                    "ssl": {
                        "type": "boolean",
                        "default": False,
                        "description": "Force SSL mode"
                    },
                    "port": {
                        "type": "integer",
                        "description": "Target port (default: 80 for HTTP, 443 for HTTPS)"
                    }
                },
                "required": ["target"]
            }
        ),
        Tool(
            name="sqlmap_test",
            description="SQL injection vulnerability scanner - automatically detects and exploits SQL injection flaws. Use for database security testing.",
            inputSchema={
                "type": "object",
                "properties": {
                    "url": {
                        "type": "string",
                        "description": "Target URL with parameters (e.g., http://example.com/page?id=1)"
                    },
                    "method": {
                        "type": "string",
                        "enum": ["GET", "POST"],
                        "default": "GET",
                        "description": "HTTP method"
                    },
                    "data": {
                        "type": "string",
                        "description": "POST data (for POST method)"
                    },
                    "level": {
                        "type": "integer",
                        "minimum": 1,
                        "maximum": 5,
                        "default": 1,
                        "description": "Test level (1-5, higher = more tests)"
                    }
                },
                "required": ["url"]
            }
        ),
        Tool(
            name="wpscan_test",
            description="WordPress security scanner - identifies vulnerabilities in WordPress installations, plugins, and themes. Use for WordPress site security audits.",
            inputSchema={
                "type": "object",
                "properties": {
                    "url": {
                        "type": "string",
                        "description": "WordPress site URL (e.g., https://wordpress.example.com)"
                    },
                    "enumerate": {
                        "type": "string",
                        "enum": ["vp", "ap", "tt", "cb", "dbe", "u"],
                        "default": "vp",
                        "description": "Enumerate: vp=vulnerable plugins, ap=all plugins, tt=themes, cb=config backups, dbe=db exports, u=users"
                    },
                    "api_token": {
                        "type": "string",
                        "description": "WPScan API token for vulnerability data"
                    }
                },
                "required": ["url"]
            }
        ),
        Tool(
            name="dirb_scan",
            description="Web content scanner - brute force directories and files on web servers. Use for discovering hidden resources and endpoints.",
            inputSchema={
                "type": "object",
                "properties": {
                    "url": {
                        "type": "string",
                        "description": "Target URL (e.g., http://example.com)"
                    },
                    "wordlist": {
                        "type": "string",
                        "enum": ["common", "small", "big"],
                        "default": "common",
                        "description": "Wordlist size: common (4k), small (20k), big (220k)"
                    },
                    "extensions": {
                        "type": "string",
                        "description": "File extensions to search (e.g., php,html,txt)"
                    }
                },
                "required": ["url"]
            }
        ),
        Tool(
            name="searchsploit_query",
            description="Exploit database search - finds known exploits for software vulnerabilities. Use to research potential exploits for identified services.",
            inputSchema={
                "type": "object",
                "properties": {
                    "query": {
                        "type": "string",
                        "description": "Search query (software name, version, CVE, etc.)"
                    },
                    "exact": {
                        "type": "boolean",
                        "default": False,
                        "description": "Exact match only"
                    },
                    "json_output": {
                        "type": "boolean",
                        "default": True,
                        "description": "Return JSON formatted results"
                    }
                },
                "required": ["query"]
            }
        )
    ]


@app.call_tool()
async def call_tool(name: str, arguments: Any) -> list[TextContent]:
    """Execute security testing tool."""
    
    try:
        if name == "nmap_scan":
            target = sanitize_target(arguments["target"])
            
            if not check_network_permission(target):
                return [TextContent(
                    type="text",
                    text=f"ERROR: Scanning {target} is not permitted. Only localhost/internal networks allowed for educational use."
                )]
            
            scan_type = arguments.get("scan_type", "quick")
            scan_args = {
                "quick": ["-T4", "-F"],
                "full": ["-p-"],
                "stealth": ["-sS", "-T2"],
                "udp": ["-sU", "--top-ports", "100"],
                "service": ["-sV", "-T4"]
            }
            
            command = ["nmap"] + scan_args[scan_type] + [target]
            
            if "additional_args" in arguments:
                command.extend(arguments["additional_args"].split())
            
            result = await run_docker_command(command)
            
            return [TextContent(
                type="text",
                text=f"# Nmap Scan Results\n\nTarget: {target}\nScan Type: {scan_type}\n\n```\n{result['stdout']}\n```"
            )]
        
        elif name == "nikto_scan":
            target = arguments["target"]
            
            # Extract hostname for permission check
            hostname = target.split("://")[-1].split("/")[0].split(":")[0]
            if not check_network_permission(hostname):
                return [TextContent(
                    type="text",
                    text=f"ERROR: Scanning {hostname} is not permitted. Only localhost/internal networks allowed."
                )]
            
            command = ["nikto", "-h", target]
            
            if arguments.get("ssl"):
                command.extend(["-ssl"])
            
            if "port" in arguments:
                command.extend(["-p", str(arguments["port"])])
            
            result = await run_docker_command(command, timeout=600)  # 10 min for web scans
            
            return [TextContent(
                type="text",
                text=f"# Nikto Web Scan Results\n\nTarget: {target}\n\n```\n{result['stdout']}\n```"
            )]
        
        elif name == "sqlmap_test":
            url = arguments["url"]
            
            # Extract hostname
            hostname = url.split("://")[-1].split("/")[0].split(":")[0]
            if not check_network_permission(hostname):
                return [TextContent(
                    type="text",
                    text=f"ERROR: Testing {hostname} is not permitted."
                )]
            
            command = ["sqlmap", "-u", url, "--batch", "--level", str(arguments.get("level", 1))]
            
            if arguments.get("method") == "POST" and "data" in arguments:
                command.extend(["--data", arguments["data"]])
            
            result = await run_docker_command(command, timeout=600)
            
            return [TextContent(
                type="text",
                text=f"# SQLMap Injection Test Results\n\nURL: {url}\n\n```\n{result['stdout']}\n```"
            )]
        
        elif name == "wpscan_test":
            url = arguments["url"]
            
            hostname = url.split("://")[-1].split("/")[0]
            if not check_network_permission(hostname):
                return [TextContent(
                    type="text",
                    text=f"ERROR: Scanning {hostname} is not permitted."
                )]
            
            command = ["wpscan", "--url", url, "--enumerate", arguments.get("enumerate", "vp")]
            
            if "api_token" in arguments:
                command.extend(["--api-token", arguments["api_token"]])
            
            result = await run_docker_command(command, timeout=600)
            
            return [TextContent(
                type="text",
                text=f"# WPScan Results\n\nURL: {url}\n\n```\n{result['stdout']}\n```"
            )]
        
        elif name == "dirb_scan":
            url = arguments["url"]
            
            hostname = url.split("://")[-1].split("/")[0]
            if not check_network_permission(hostname):
                return [TextContent(
                    type="text",
                    text=f"ERROR: Scanning {hostname} is not permitted."
                )]
            
            wordlist_paths = {
                "common": "/usr/share/dirb/wordlists/common.txt",
                "small": "/usr/share/dirb/wordlists/small.txt",
                "big": "/usr/share/dirb/wordlists/big.txt"
            }
            
            wordlist = wordlist_paths[arguments.get("wordlist", "common")]
            command = ["dirb", url, wordlist]
            
            if "extensions" in arguments:
                command.extend(["-X", arguments["extensions"]])
            
            result = await run_docker_command(command, timeout=900)  # 15 min for directory brute force
            
            return [TextContent(
                type="text",
                text=f"# Dirb Directory Scan Results\n\nURL: {url}\n\n```\n{result['stdout']}\n```"
            )]
        
        elif name == "searchsploit_query":
            query = arguments["query"]
            
            # searchsploit is safe - no network access, just database search
            command = ["searchsploit"]
            
            if arguments.get("exact"):
                command.append("-e")
            
            if arguments.get("json_output", True):
                command.append("--json")
            
            command.append(query)
            
            result = await run_docker_command(command)
            
            return [TextContent(
                type="text",
                text=f"# Exploit Database Search Results\n\nQuery: {query}\n\n```\n{result['stdout']}\n```"
            )]
        
        else:
            return [TextContent(
                type="text",
                text=f"ERROR: Unknown tool: {name}"
            )]
    
    except ValueError as e:
        logger.warning(f"Validation error in {name}: {e}")
        return [TextContent(
            type="text",
            text=f"ERROR: Invalid input - {str(e)}"
        )]
    except RuntimeError as e:
        logger.error(f"Runtime error in {name}: {e}")
        return [TextContent(
            type="text",
            text=f"ERROR: Execution failed - {str(e)}"
        )]
    except Exception as e:
        logger.error(f"Unexpected error in {name}: {e}", exc_info=True)
        return [TextContent(
            type="text",
            text=f"ERROR: Unexpected error - {str(e)}"
        )]


async def main():
    """Run the MCP server."""
    logger.info("Starting MCP Kali Pentest Server")
    logger.warning("Educational use only - unauthorized scanning is illegal")
    
    async with stdio_server() as (read_stream, write_stream):
        await app.run(
            read_stream,
            write_stream,
            app.create_initialization_options()
        )


if __name__ == "__main__":
    asyncio.run(main())
