"""Tests for nmap_scan tool."""

import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from src.server import call_tool, sanitize_target, check_network_permission


class TestSanitizeTarget:
    """Test input sanitization."""
    
    def test_valid_ip(self):
        """Should accept valid IP addresses."""
        assert sanitize_target("192.168.1.1") == "192.168.1.1"
        assert sanitize_target("10.0.0.0/24") == "10.0.0.0/24"
    
    def test_valid_hostname(self):
        """Should accept valid hostnames."""
        assert sanitize_target("example.com") == "example.com"
        assert sanitize_target("sub.example.com") == "sub.example.com"
    
    def test_invalid_chars(self):
        """Should reject targets with injection characters."""
        with pytest.raises(ValueError):
            sanitize_target("192.168.1.1; rm -rf /")
        
        with pytest.raises(ValueError):
            sanitize_target("example.com | cat /etc/passwd")
        
        with pytest.raises(ValueError):
            sanitize_target("$(whoami)")
    
    def test_special_chars(self):
        """Should reject targets with dangerous special characters."""
        dangerous = [';', '|', '&', '$', '`', '(', ')']
        for char in dangerous:
            with pytest.raises(ValueError):
                sanitize_target(f"test{char}bad")


class TestNetworkPermission:
    """Test network permission checks."""
    
    def test_localhost_allowed(self):
        """Should allow localhost scanning."""
        assert check_network_permission("127.0.0.1") is True
        assert check_network_permission("localhost") is True
    
    def test_external_blocked(self):
        """Should block external network scanning by default."""
        assert check_network_permission("8.8.8.8") is False
        assert check_network_permission("google.com") is False
    
    @patch.dict('os.environ', {'ALLOWED_NETWORKS': '127.0.0.1,192.168.1.0/24'})
    def test_custom_allowed_networks(self):
        """Should respect custom allowed networks."""
        assert check_network_permission("192.168.1.100") is True


@pytest.mark.asyncio
class TestNmapScan:
    """Test nmap_scan tool."""
    
    @patch('src.server.run_docker_command')
    async def test_quick_scan_localhost(self, mock_docker):
        """Should execute quick nmap scan on localhost."""
        mock_docker.return_value = {
            "stdout": "Nmap scan report for localhost (127.0.0.1)\nPORT STATE SERVICE\n22/tcp open ssh\n",
            "stderr": "",
            "exit_code": 0
        }
        
        result = await call_tool("nmap_scan", {
            "target": "127.0.0.1",
            "scan_type": "quick"
        })
        
        assert len(result) == 1
        assert "127.0.0.1" in result[0].text
        assert "Nmap Scan Results" in result[0].text
        mock_docker.assert_called_once()
    
    @patch('src.server.run_docker_command')
    async def test_service_detection(self, mock_docker):
        """Should execute service version detection scan."""
        mock_docker.return_value = {
            "stdout": "22/tcp open ssh OpenSSH 8.9p1\n80/tcp open http Apache 2.4.52\n",
            "stderr": "",
            "exit_code": 0
        }
        
        result = await call_tool("nmap_scan", {
            "target": "localhost",
            "scan_type": "service"
        })
        
        assert len(result) == 1
        assert "service" in result[0].text.lower()
    
    async def test_external_network_blocked(self):
        """Should block scanning external networks."""
        result = await call_tool("nmap_scan", {
            "target": "8.8.8.8",
            "scan_type": "quick"
        })
        
        assert len(result) == 1
        assert "ERROR" in result[0].text
        assert "not permitted" in result[0].text
    
    async def test_invalid_target(self):
        """Should reject targets with injection attempts."""
        result = await call_tool("nmap_scan", {
            "target": "127.0.0.1; whoami",
            "scan_type": "quick"
        })
        
        assert len(result) == 1
        assert "ERROR" in result[0].text
        assert "Invalid" in result[0].text


@pytest.mark.asyncio
class TestNiktoScan:
    """Test nikto_scan tool."""
    
    @patch('src.server.run_docker_command')
    async def test_basic_web_scan(self, mock_docker):
        """Should execute basic Nikto web scan."""
        mock_docker.return_value = {
            "stdout": "- Nikto v2.5.0\n+ Target IP: 127.0.0.1\n+ Server: Apache/2.4.52\n",
            "stderr": "",
            "exit_code": 0
        }
        
        result = await call_tool("nikto_scan", {
            "target": "http://localhost"
        })
        
        assert len(result) == 1
        assert "Nikto" in result[0].text
        assert "localhost" in result[0].text
    
    @patch('src.server.run_docker_command')
    async def test_ssl_scan(self, mock_docker):
        """Should execute SSL scan."""
        mock_docker.return_value = {
            "stdout": "SSL test results...",
            "stderr": "",
            "exit_code": 0
        }
        
        result = await call_tool("nikto_scan", {
            "target": "https://localhost",
            "ssl": True,
            "port": 443
        })
        
        assert len(result) == 1
        mock_docker.assert_called_once()


@pytest.mark.asyncio
class TestSearchsploit:
    """Test searchsploit_query tool."""
    
    @patch('src.server.run_docker_command')
    async def test_exploit_search(self, mock_docker):
        """Should search exploit database."""
        mock_docker.return_value = {
            "stdout": '{"RESULTS_EXPLOIT": [{"Title": "Apache 2.4.49 - RCE", "Path": "/exploits/linux/remote/50383.sh"}]}',
            "stderr": "",
            "exit_code": 0
        }
        
        result = await call_tool("searchsploit_query", {
            "query": "apache 2.4.49"
        })
        
        assert len(result) == 1
        assert "apache 2.4.49" in result[0].text.lower()
    
    @patch('src.server.run_docker_command')
    async def test_exact_search(self, mock_docker):
        """Should perform exact match search."""
        mock_docker.return_value = {
            "stdout": "No results",
            "stderr": "",
            "exit_code": 0
        }
        
        result = await call_tool("searchsploit_query", {
            "query": "CVE-2021-44228",
            "exact": True
        })
        
        assert len(result) == 1


@pytest.mark.asyncio
class TestErrorHandling:
    """Test error handling."""
    
    @patch('src.server.run_docker_command')
    async def test_docker_error(self, mock_docker):
        """Should handle Docker execution errors gracefully."""
        mock_docker.side_effect = RuntimeError("Docker daemon not running")
        
        result = await call_tool("nmap_scan", {
            "target": "127.0.0.1"
        })
        
        assert len(result) == 1
        assert "ERROR" in result[0].text
    
    async def test_unknown_tool(self):
        """Should handle unknown tool names."""
        result = await call_tool("unknown_tool", {})
        
        assert len(result) == 1
        assert "ERROR" in result[0].text
        assert "Unknown tool" in result[0].text
